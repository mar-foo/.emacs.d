#+TITLE: Emacs configuration
#+STARTUP: overview
#+AUTHOR: Mario Forzanini
#+HTML_HEAD: <link rel="stylesheet" href="style/simple.css">
* Look and Feel
** Icons
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package all-the-icons)
  (use-package emojify
    :defer t
    :commands (emojify-mode)
    :hook
    (elfeed-mode-hook . emojify-mode)
    (eww-mode-hook . emojify-mode))
#+end_src
** Line numbers
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (column-number-mode)
      (global-display-line-numbers-mode t)
      (menu-bar--display-line-numbers-mode-relative)

      (dolist (mode '(term-mode-hook
                      completion-list-mode-hook
                      eshell-mode-hook
                      vterm-mode-hook
                      helpful-mode-hook
                      elfeed-search-mode
                      elfeed-show-mode
                      org-mode-hook))
        (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
** Elisp parentheses
Use [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] for nice parentheses coloring
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package rainbow-delimiters
    :defer t
    :commands rainbow-delimiters-mode
    :hook
    (org-mode . rainbow-delimiters-mode)
    (prog-mode . rainbow-delimiters-mode))
#+end_src
* Keybindings
** Evil mode
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
    (use-package evil
      :init
      (setq evil-want-integration t
       evil-want-keybinding nil)
      :config
      (evil-mode 1))
#+END_SRC
** Leader key definitions
*** Helper functions
#+begin_src emacs-lisp  :tangle ~/.emacs.d/GNUEmacs.el
  (defun mf/reload-configuration ()
    "Reloads configuration"
    (interactive)
    (load-file (concat user-emacs-directory "init.el")))

  (defun mf/edit-configuration ()
    "Edit emacs configuration"
    (interactive)
    (find-file "~/.emacs.d/GNUEmacs.org"))

  (defun mf/find-recentf ()
    "Open a recent file"
    (interactive)
    (find-file (completing-read "Recent File: " recentf-list nil t)))

  (defun mf/toggle-vterm (&optional use-generic-p)
    "Toggle vterm window respecting buffer-alist configuration.
    If there is a prefix argument, switch to the vterm buffer."
    (interactive "P")
    (if (get-buffer-window "*vterm*")
        (delete-window (get-buffer-window "*vterm*"))
      (if use-generic-p
          (switch-to-buffer "*vterm*")
        (vterm))))
#+end_src
*** Leader key
Use [[https://github.com/noctuid/general.el][general]] to setup space bar as leader key in normal mode, C-c in
other modes. C-c-m is the major-mode-specific leader
#+begin_src emacs-lisp  :tangle ~/.emacs.d/GNUEmacs.el
  (use-package general
    :init
    (general-override-mode 1)
    :config
    (general-evil-setup t)

    (general-create-definer mf/leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC")
#+end_src
**** General definitions
Commonly used bindings for different purposes; Prefix: C-c
| Keybinding | Action              |
|------------+---------------------|
| SPC-b      | Buffers prefix      |
| SPC-f      | Files prefix        |
| SPC-h      | Help prefix         |
| SPC-i      | Insert prefix       |
| SPC-m      | Major mode prefix   |
| SPC-O      | Org prefix          |
| SPC-q      | Quit prefix         |
| SPC-q-q    | Exit Emacs          |
| SPC-w      | Window prefix       |
| SPC-/      | Music prefix        |
| SPC-SPC    | M-x                 |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/GNUEmacs.el
  (mf/leader-keys
    "a" '(:ignore t :which-key "Applications")
    "b" '(:ignore t :which-key "Buffers")
    "c" '(:ignore t :which-key "Code")
    "f" '(:ignore t :which-key "Files")
    "g" '(:ignore t :which-key "Git")
    "h" '(:ignore t :which-key "Help")
    "i" '(:ignore t :which-key "Insert")
    "j" '(:ignore t :which-key "Jump")
    "q" '(:ignore t :which-key "Quit")
    "t" '(:ignore t :which-key "Toggle")
    "w" '(:ignore t :which-key "Windows")
    "O" '(:ignore t :which-key "Org")

    "SPC" '(execute-extended-command :which-key "M-x")
    "qq" '(save-buffers-kill-terminal :which-key "Exit Emacs")
#+end_src
**** Buffer management
Quick bookmarks; Prefix: C-c-b
| Keybinding | Action        |
|------------+---------------|
| SPC-b-d    | Delete buffer |
| SPC-b-r    | Rename buffer |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/GNUEmacs.el
  "bd"  '(kill-current-buffer :which-key "Delete buffer")
  "br" '(rename-buffer :which-key "Rename buffer")
#+end_src
**** Code
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
"cc" '(compile :which-key "Compile")
"ce" '(eval-buffer :which-key "Eval buffer")
"cr" '(recompile :which-key "Recompile")
"cE" '(eval-region :which-key "Eval region")
#+END_SRC
**** File management
Movement in the filesystem; Prefix: C-c-f
| Keybinding | Action                   |
|------------+--------------------------|
| SPC-f-s    | Save buffer              |
| SPC-f-e    | Emacs prefix             |
| SPC-f-e-d  | Edit emacs configuration |
| SPC-f-e-R  | Reload emacs configuration |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/GNUEmacs.el
  "fd" '(dired :which-key "Dired")
  "ff" '(find-file :which-key "Find-file")
  "fe" '(:ignore t :which-key "Emacs")
  "fed" '(mf/edit-configuration :which-key "Emacs configuration")
  "feR" '(mf/reload-configuration :which-key "Reload configuration")
  "fr" '(mf/find-recentf :which-key "Recent files")
  "fs" '(save-buffer :which-key "Save buffer")
#+end_src
**** Help
| Keybindings | Action                |
|-------------+-----------------------|
| SPC-h-a     | Apropos               |
| SPC-h-c     | Key briefly           |
| SPC-h-d     | Apropos documentation |
| SPC-h-e     | Emacs                 |
| SPC-h-i     | Info                  |
| SPC-h-k     | Key                   |
| SPC-h-l     | Lossage               |
| SPC-h-m     | Mode                  |
| SPC-h-n     | Emacs news            |
| SPC-h-q     | Quit                  |
| SPC-h-r     | Info emacs            |
| SPC-h-s     | Syntax                |
| SPC-h-C     | Coding system         |
| SPC-h-F     | Info command          |
| SPC-h-I     | Input method          |
| SPC-h-K     | Info key              |
| SPC-h-L     | Language environment  |
| SPC-h-P     | Package               |
| SPC-h-S     | Symbol                |
| SPC-h-?     | Help                  |
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
"ha" '(apropos-command :which-key "Apropos")
"hb" '(describe-bindings :which-key "Bindings")
"hc" '(describe-key-briefly :which-key "Key briefly")
"hd" '(apropos-documentation :which-key "Apropos documentation")
"he" '(about-emacs :which-key "Emacs")
"hf" '(describe-function :which-key "Function")
"hi" '(info :which-key "Info")
"hk" '(describe-key :which-key "Key")
"hl" '(view-lossage :which-key "Lossage")
"hm" '(describe-mode :which-key "Mode")
"hn" '(view-emacs-news :which-key "Emacs news")
"hq" '(help-quit :which-key "Quit")
"hr" '(info-emacs-manual :which-key "Info emacs")
"hs" '(describe-syntax :which-key "Syntax")
"hv" '(describe-variable :which-hey "Variable")
"hC" '(describe-coding-system :which-key "Coding system")
"hF" '(Info-goto-emacs-command-node :which-key "Info command")
"hI" '(describe-input-method :which-key "Input method")
"hK" '(Info-goto-emacs-key-command-node :which-key "Info key")
"hL" '(describe-language-environment :which-key "Language environment")
"hP" '(describe-package :which-key "Package")
"hS" '(info-lookup-symbol :which-key "Info symbol")
"h?" '(help-for-help :which-key "Help")
#+END_SRC
**** J
#+begin_src emacs-lisp
"j(" '(check-parens :which-key "Check parens")
#+end_src
**** Toggle
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  "tr" '(read-only-mode :which-key "Read only mode")
  "tw" '(visual-line-mode :which-key "Soft line wrapping")
;; Define functions to toggle auto-completion, smartparens, yasnippet...
#+END_SRC
**** Windows
    Manage windows; Prefix: SPC-w
| Keybinding | Action           |
|------------+------------------|
| SPC-w-h    | Focus left       |
| SPC-w-l    | Focus right      |
| SPC-w-j    | Focus down       |
| SPC-w-k    | Focus up         |
| SPC-w-c    | Close            |
| SPC-w-q    | Close            |
| SPC-w-v    | Vertical split   |
| SPC-w-s    | Horizontal split |
| SPC-w-m    | Maximize         |
| SPC-w-=    | Balance windows  |
| SPC-w-w    | Other-window     |
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  "wh" '(windmove-left :which-key "Focus left")
  "wl" '(windmove-right :which-key "Focus-right")
  "wj" '(windmove-down :which-key "Focus Down")
  "wk" '(windmove-up :which-key "Focus Up")
  "wc" '(delete-window :which-key "Close")
  "wq" '(delete-window :which-key "Close")
  "wv" '(split-window-right :which-key "Vertical-split")
  "ws" '(split-window-below :which-key "Horizontal split")
  "wm" '(maximize-window :which-key "Maximize")
  "w=" '(balance-windows :which-key "Balance windows")
  "ww" '(other-window :which-key "Other window")
  ))
#+END_SRC
** Jumping with Avy
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package avy
    :defer t
    :commands (avy-goto-char avy-goto-char-2 avy-goto-word-0 avy-goto-line avy-goto-word-1)
    :general (mf/leader-keys
               "jj" '(avy-goto-char-2 :which-key "Goto char 2")
               "jJ" '(avy-goto-char :which-key "Goto char")
               "jw" '(avy-goto-word-1 :which-key "Goto word")
               "jW" '(avy-goto-word-0 :which-key "Goto any word")
               "jl" '(avy-goto-line :which-key "Goto line")
               "l" '(avy-goto-line :which-key "Goto line")))
#+END_SRC
** Hydra
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package hydra
    :defer t
    :commands hydra-resize/body)
#+end_src
*** Window resizing
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (defun mf/window-enlarge ()
        (interactive)
        (shrink-window -6 t))
      (defun mf/window-shrink ()
        (interactive)
        (shrink-window 6 t))
      (defun mf/window-taller ()
        (interactive)
        (shrink-window -6 nil))
      (defun mf/window-shorter ()
        (interactive)
        (shrink-window 6 nil))
      (defun mf/window-big-enlarge ()
        (interactive)
        (shrink-window -12 t))
      (defun mf/window-big-shrink ()
        (interactive)
        (shrink-window 12 t))
      (defun mf/window-big-taller ()
        (interactive)
        (shrink-window -12 nil))
      (defun mf/window-big-shorter ()
        (interactive)
        (shrink-window 12 nil))

      (defhydra hydra-resize (global-map "C-c r")
        "resize"
        ("h" mf/window-shrink)
        ("l" mf/window-enlarge)
        ("j" mf/window-taller)
        ("k" mf/window-shorter)
        ("H" mf/window-big-shrink)
        ("L" mf/window-big-enlarge)
        ("J" mf/window-big-taller)
        ("K" mf/window-big-shorter)
        ("n" windmove-down)
        ("p" windmove-up)
        ("b" windmove-left)
        ("f" windmove-right)
        ("r" rotate-window)
        ("0" delete-window)
        ("2" split-window-below)
        ("3" split-window-right)
        ("q" nil))
#+end_src
*** Buffer cycling
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (defhydra hydra-buf-cycle (global-map "C-c b b")
    "cycle"
    ("d" kill-current-buffer)
    ("j" scroll-up-command)
    ("k" scroll-down-command)
    ("n" bs-cycle-next)
    ("p" bs-cycle-previous)
    ("q" nil))
#+end_src
** Evil integrations
Use [[https://github.com/emacs-evil/evil][evil]] keybindings to make my life better, [[https://github.com/emacs-evil/evil-collection][evil-collection]] to use
vim keybindings in many modes and [[https://github.com/Alexander-Miller/treemacs][treemacs-evil]] to use vim keybindings
in treemacs navigation
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el 
    (use-package evil-collection
      :after evil
      :config
      (evil-collection-init)
    (setq evil-want-C-i-jump t))
#+end_src
* Completion framework
** Icomplete
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package prescient
    :defer t
    :hook (minibuffer-inactive-mode-hook . prescient-persistent-mode))
#+end_src
** Make use of the Emacs default minibuffer
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package marginalia
    :init
    (marginalia-mode))

  (use-package orderless
    :config
    (defun my-orderless-initialism-dispatcher (pattern _index _total)
      "Leading initialism dispatcher using the comma suffix.
                                   It matches PATTERN _INDEX and _TOTAL according to how Orderless parses it input."
      (when (string-suffix-p "," pattern)
        `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))
    (defun my-orderless-literal-dispatcher (pattern _index _total)
      "Literal style dispatcher using the equal sign as a suffix.
                                   It matches PATTERN _INDEX and _TOTAL according to how Orderless parses it input."
      (when (string-suffix-p "=" pattern )
        `(orderless-literal . ,(substring pattern 0 -1))))
    (defun my-orderless-flex-dispatcher (pattern _index _total)
      "Flex dispatcher using the tilde suffix.
                     It matches PATTERN _INDEX and _TOTAL according to how Orderless
                     parses its input."
      (when (string-suffix-p "~" pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))
    (setq my-orderless-default-styles
          '(orderless-strict-leading-initialism
            orderless-flex
            orderless-prefixes
            orderless-regexp)
          orderless-component-separator "[ &]"      ; Completion at point using & as a separator, SPC automatically exits completion
          orderless-matching-styles my-orderless-default-styles
          orderless-style-dispatchers
          '(my-orderless-literal-dispatcher
            my-orderless-initialism-dispatcher
            my-orderless-flex-dispatcher)
          completion-styles '(orderless))
    (let ((map minibuffer-local-completion-map))
      ;; SPC should never complete, use it for orderless groups'
      (define-key map (kbd "SPC") nil)
      (define-key map (kbd "?") nil)))
#+end_src
** Which key
Use [[https://github.com/justbur/emacs-which-key][which-key]] to get information about keybindings while pressing them
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package which-key
    :defer t
    :commands (which-key-mode)
    :config
    (setq which-key-idle-delay 10000
          which-key-show-early-on-C-h t
          which-key-order 'which-key-prefix-then-key-order
          which-key-idle-secondar-delay 0.05
          which-key-min-display-lines 3))
#+end_src
** Embark
Contextually relevant keybindings under a simple prefix key
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package embark
    :defer t
    :commands (embark-act)
    :init
    (define-key global-map (kbd "C-,") #'embark-act)
    (let ((map minibuffer-local-completion-map))
      (define-key map (kbd "C-,") #'embark-act)
      (define-key map (kbd "C->") #'embark-become)
      (define-key map (kbd "M-q") #'embark-collect-toggle-view))
    :hook (which-key-mode . (lambda ()
                              (setq embark-action-indicator
                                    (lambda (map _target)
                                      (which-key--show-keymap "Embark" map nil nil 'no-paging)
                                      #'which-key--hide-popup-ignore-command)
                                    embark-become-indicator embark-action-indicator)))
    :config
    (setq embark-collect-initial-view-alist
          '((file . list)
            (buffer . list)
            (symbol . list)
            (line . list)
            (xref-location . list)
            (kill-ring . zebra)
            (t . list))
          embark-quit-after-action t
          embark-collect-live-update-delay 0.5
          embark-collect-live-initial-delay 0.8
          embark-prompter 'embark-keymap-prompter)
     (let ((map embark-collect-mode-map))
      (define-key map (kbd "C-,") #'embark-act)
      (define-key map (kbd ",") #'embark-act)
      (define-key map (kbd "M-q") #'embark-collect-toggle-view))
    (let ((map embark-region-map))
      (define-key map (kbd "a") #'align-regexp)
      (define-key  map (kbd "s") #'sort-lines))
    (let ((map embark-symbol-map))
      (define-key map (kbd ".") #'embark-find-definition)
      (define-key map (kbd "k") #'describe-keymap)))
#+end_src
From [[https://www.protesilaos.com][protesilaos]] config
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (defun prot-minibuffer-focus-minibuffer ()
        "Focus the active minibuffer."
        (interactive)
        (let ((mini (active-minibuffer-window)))
          (when mini
            (select-window mini))))

      (defun prot-minibuffer--fit-completions-window ()
        "Fit Completions' buffer to its window."
        (fit-window-to-buffer (get-buffer-window "*Completions*")
                              (floor (frame-height) 2) 1))

      (defun prot-common-number-negative ( n )
        "Make N negative."
        (if (and (numberp n) (> n 0))
            (* -1 n)
          (error "%s is not a valid positive number" n)))


      (defun prot-minibuffer--switch-to-completions ()
        "Subroutine for switching to the completions' buffer."
        (unless (get-buffer-window "*Completions*" 0)
          (minibuffer-completion-help))
        (switch-to-completions)
        (prot-minibuffer--fit-completions-window))

      (defun prot-minibuffer-switch-to-completions-top ()
        "Switch to the top of the completions' buffer.
                    Meant to be bound in `minibuffer-local-completion-map'."
        (interactive)
        (prot-minibuffer--switch-to-completions)
        (goto-char (point-min))
        (next-completion 1))

      (defun prot-minibuffer-switch-to-completions-bottom ()
        "Switch to the bottom of the completions' buffer.
                    Meant to be bound in `minibuffer-local-completion-map'."
        (interactive)
        (prot-minibuffer--switch-to-completions)
        (goto-char (point-max))
        (next-completion -1)
        (goto-char (point-at-bol))
        (recenter
         (- -1
            (min (max 0 scroll-margin)
                 (truncate (/ (window-body-height) 4.0))))
         t))

      (defun prot-minibuffer-next-completion-or-mini (&optional arg)
        "Move to the next completion or switch to the minibuffer.
                    This performs a regular motion for optional ARG lines, but when
                    point can no longer move in that direction it switches to the
                    minibuffer."
        (interactive "p")
        (cond
         ((and (bobp)   ; see hack in `prot-minibuffer--clean-completions'
               (get-text-property (point) 'invisible))
          (forward-char 1)
          (next-completion (or arg 1)))
         ((or (eobp)
              (eq (point-max)
                  (save-excursion (forward-line 1) (point))))
          (prot-minibuffer-focus-minibuffer))
         (t
          (next-completion (or arg 1))))
        (setq this-command 'next-line))

      (defun prot-minibuffer-previous-completion-or-mini (&optional arg)
        "Move to the next completion or switch to the minibuffer.
                    This performs a regular motion for optional ARG lines, but when
                    point can no longer move in that direction it switches to the
                    minibuffer."
        (interactive "p")
        (let ((num (prot-common-number-negative arg)))
          (if (or (bobp)
                  (eq (point) (1+ (point-min)))) ; see hack in `prot-minibuffer--clean-completions'
              (prot-minibuffer-focus-minibuffer)
            (next-completion (or num 1)))))
  ;; Copied from icomplete.el
  (defun prot-minibuffer--field-beg ()
    "Determine beginning of completion."
    (if (window-minibuffer-p)
        (minibuffer-prompt-end)
      (nth 0 completion-in-region--data)))
    (defun prot-minibuffer--completion-category ()
      "Return completion category."
      (let* ((beg (prot-minibuffer--field-beg))
             (md (completion--field-metadata beg)))
        (alist-get 'category (cdr md))))
    (defun prot-minibuffer-backward-updir ()
      "Delete char before point or go up a directory.
    Must be bound to `minibuffer-local-filename-completion-map'."
      (interactive)
      (if (and (eq (char-before) ?/)
               (eq (prot-minibuffer--completion-category) 'file))
          (save-excursion
            (goto-char (1- (point)))
            (when (search-backward "/" (point-min) t)
              (delete-region (1+ (point)) (point-max))))
        (call-interactively 'backward-delete-char)))
#+end_src
** Minibuffer completions
Adjust completions buffer size (and all temp buffers)
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (setq temp-buffer-max-height 10)
  (temp-buffer-resize-mode)
#+end_src
Override completion style for buffer and file name completions
(~/.em/el/ expands to ~/.emacs.d/elpa no matter what text there is
befor the ~)
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (file-name-shadow-mode 1)
  (setq completion-styles '(orderless partial-completion))
  (setq completion-category-overrides
        '((buffer (styles . (substring flex orderless)))
          (file (styles . (partial-completion orderless)))))
#+end_src
Set important variables
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (setq completion-cycle-threshold nil)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-show-help nil)
  (setq completion-auto-help t)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq completions-format 'vertical)
  (setq completions-detailed t)
  (setq resize-mini-windows nil)
  (setq minibuffer-eldef-shorten-default t)
  (setq echo-keystrokes 0.25)
  (file-name-shadow-mode 1)
  (minibuffer-electric-default-mode 1)
#+end_src
Keybindings
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (let ((map completion-list-mode-map))
    (define-key map (kbd "C-n") #'prot-minibuffer-next-completion-or-mini)
    (define-key map (kbd "C-p") #'prot-minibuffer-previous-completion-or-mini))
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-n") #'prot-minibuffer-switch-to-completions-top)
    (define-key map (kbd "C-p") #'prot-minibuffer-switch-to-completions-bottom)
    (define-key map (kbd "RET") #'minibuffer-force-complete-and-exit))
  (let ((map minibuffer-local-filename-completion-map))
    (define-key map (kbd "<M-backspace>") #'prot-minibuffer-backward-updir))
#+end_src
** Corfu
Use corfu for better completions at point
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package corfu
    :config (corfu-global-mode))
#+end_src
** Helpful
Use [[https://github.com/Wilfred/helpful][helpful]] to get better help, highlighting and references to the
source files
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package helpful
    :defer t
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :hook
    (helpful-mode . page-break-lines-mode)
    (helpful-mode . visual-line-mode)
    :bind
    ([remap describe-variable] . helpful-variable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key)
    (:map helpful-mode-map
          ("q" . mf/quit-and-kill)					; Quitting help buffer kills them too
          ("n" . next-line)
          ("p" . previous-line))
    :config
    (defun mf/quit-and-kill ()
      (interactive)
      (quit-window t)))
#+end_src
* Programming
** Autocompletion
Get [[http://company-mode.github.io/][autocompletion]]. Edit: try to use Emacs' built in completion-at-point
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (setq tab-always-indent 'complete)
  (autoload 'ffap-file-at-point "ffap")
  (defun complete-path-at-point+ ()
    "Return completion data for UNIX path at point."
    (let ((fn (ffap-file-at-point))
          (fap (thing-at-point 'filename)))
      (when (and (or fn (equal "/" fap))
                 (save-excursion
                   (search-backward fap (line-beginning-position) t)))
        (list (match-beginning 0)
              (match-end 0)
              #'completion-file-name-table :exclusive 'no))))

  (add-hook 'completion-at-point-functions
            #'complete-path-at-point+
            'append)
#+end_src
** Projectile
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package projectile
      :defer t
      :commands projectile-mode
      :hook
      (c-mode . projectile-mode)
      (c++-mode . projectile-mode)
      (emacs-lisp-mode . projectile-mode))
#+end_src
** Groff
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
     (defun mf/nroff-startup ()
       (setq visual-fill-column-width 100
             visual-fill-column-center-text t)
       (visual-fill-column-mode 1)
       (auto-fill-mode 1))

     (add-hook 'nroff-mode-hook #'mf/nroff-startup)
#+end_src
** Haskell
#+begin_src emacs-lisp
  (use-package hindent
    :defer t
    :hook (haskell-mode-hook . hindent-mode)
    :config (setq hindent-reformat-buffer-on-save t))


  (use-package dante
    :after haskell-mode
    :commands 'dante-mode
    :init
    (add-hook 'haskell-mode-hook 'haskell-indent-mode)
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    (add-hook 'haskell-mode-hook 'flycheck-mode)
    (add-hook 'haskell-mode-hook 'dante-mode))
#+end_src
** Smart parentheses
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (use-package smartparens
    :defer t
    :commands smartparens-mode
    :hook
    ((prog-mode . smartparens-mode)
    (emacs-lisp-mode . smartparens-mode)
    (org-mode . smartparens-mode)
    (scheme-mode . smartparens-mode))
    :config
    (require 'smartparens-config))
#+END_SRC
** Git
Use magit to handle git repositories
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (use-package magit
    :defer t
  :commands magit
  :general (mf/leader-keys
            "gb" '(magit-branch-checkout :which-key "Switch branch")
            "gc" '(:ignore t :which-key "Create")
            "gcb" '(magit-branch-and-checkout :which-key "Branch")
            "gcc" '(magit-commit-create :which-key "Commit")
            "gcr" '(magit-init :which-key "Initialize repository")
            "gcR" '(magit-clone :which-key "Clone")
            "gf" '(:ignore t :which-key "Find")
            "gfc" '(magit-show-commit :which-key "Commit")
            "gfg" '(magit-find-git-config-file :which-key "Gitconfig file")
            "gg" '(magit-status :which-key "Status")
            "gt" '(git-timemachine-toggle :which-key "Timemachine")
            "gB" '(magit-blame-addition :which-key "Blame")
            "gC" '(magit-clone :which-key "Clone")
            "gD" '(magit-file-delete :which-key "Delete file")
            "gF" '(magit-fetch :which-key "Fetch")
            "gG" '(magit-status-here :which-key "Status here")
            "gL" '(magit-log :which-key "Log")
            "gS" '(magit-stage-file :which-key "Stage file")
            "gU" '(magit-unstage-file :which-key "Unstage file")))
#+END_SRC
* Shell
*** term-mode
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (use-package term
        :defer t
        :commands (term ansi-term)
        :config (setq explicit-shell-file-name "ksh"
         term-prompt-regexp "^\$"))
                                              ; 256 color support
      (use-package eterm-256color
        :defer t
        :after term
        :hook (term-mode . eterm-256color-mode))
#+end_src
*** eshell
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
  (defun mf/configure-eshell ()
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer))


    (use-package eshell-git-prompt
      :defer t
      :after eshell)
    (use-package eshell
      :defer t
      :commands eshell
      :hook (eshell-first-time-mode . mf/configure-eshell)
      :config
      (setq eshell-history-size 5000
	    eshell-buffer-maximum-lines 5000
	    eshell-hist-ignoredups t
	    eshell-scroll-to-bottom-on-input t)
    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "pulsemixer" "zsh"))
      (eshell-git-prompt-use-theme 'powerline)))

#+end_src
*** vterm
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
      (use-package vterm
        :defer t
        :commands vterm
        :config
        (setq vterm-shell "/bin/ksh")
        :general (mf/leader-keys
                   "RET" '(mf/toggle-vterm :which-key "vterm")))
#+end_src
* Org mode
** Setup
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
    (defun mf/org-mode-setup ()
          (org-indent-mode)
    ;;      (variable-pitch-mode 1)
    ;;      (auto-fill-mode 1)
          (visual-line-mode 1))
      (defun mf/view-org-archive ()
        (interactive)
        (find-file "~/org/archive.org"))
#+end_src
** Org
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
          (use-package org
            :defer t
            :hook (org-mode . mf/org-mode-setup)
            :general (mf/leader-keys
                       "Ot" '(:ignore t :which-key "Tangle")
                       "Ott" '(org-babe-tangle :which-key "Tangle")
                       "Otl" '(org-babel-load-file :which-key "Load file")
                       "Oa" '(org-agenda :which-key "Agenda")
                       "Oc" '(org-capture :which-key "Capture")
                       "OA" '(mf/view-org-archive :which-key "Open archive"))
            :config
            (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
            (add-to-list 'org-structure-template-alist '("S" . "src spice"))
            (setq org-agenda-files
                  '("~/org/schedule.org"
                    "~/.local/share/org/next-actions.org"
                    "~/.local/share/org/projects.org")
                  org-archive-location "~/.local/share/org/archive.org::"
                  org-agenda-include-diary t
                  org-agenda-start-with-log-mode t ;; Enable log mode
                  org-log-done 'time ;; Keep track when I complete a task
                  org-log-into-drawer t

                  org-agenda-custom-commands
                  '(("w" todo "WAITING")
                    ("n" todo "NEXT")
                    ("W" "Week Review"
                     ((agenda "" ((org-agenda-span 7)))
                      (org-agenda-files (add-to-list 'org-agenda-files "~/.local/share/org/archive.org"))))
                    ("g" "GTD view"
                     ((agenda)
                      (todo "NEXT"
                            ((org-agenda-overriding-heading "Next actions:")))
                      (todo "WAITING"
                            ((org-agenda-overriding-heading "Waiting on:")))
                      (todo "DONE"
                            ((org-agenda-overriding-heading "Completed items:")))
                      (tags-todo "projects"
                            ((org-agenda-overriding-heading "Projects in progress:"))))))
                  org-todo-keywords
                  '(( sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "PROJECT(p)" "|" "NO(x)" "DONE(d!)")))
            (setq org-ellipsis " "
                  org-hide-emphasis-markers t)
            (defun mf/mark-done-and-archive ()
              "Mark the state of an org-mode item as DONE and archive it"
              (interactive)
              (org-todo 'done)
              (org-archive-subtree))
            (define-key org-mode-map (kbd "C-c C-x C-s") 'mf/mark-done-and-archive))
#+end_src
** Bullets
Prettify [[https://github.com/integral-dw/org-bullets][org bullets]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
     (use-package org-bullets
       :defer t
       :after org
       :hook (org-mode . org-bullets-mode))
#+end_src
** Look and feel
#+begin_src emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
     (defun mf/org-mode-visual-fill ()
       (setq visual-fill-column-width 130
             visual-fill-column-center-text t)
       (visual-fill-column-mode 1))

     (use-package visual-fill-column
       :defer t
       :hook (org-mode . mf/org-mode-visual-fill))
#+end_src
** In line latex previews
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/GNUEmacs.el
        (use-package org-fragtog
          :defer t
          :after org
          :hook
         (org-mode . org-fragtog-mode)
         :bind (:map org-mode-map
                     ("C-c tf" . org-fragtog-mode)))
#+END_SRC
