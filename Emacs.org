#+TITLE: Emacs configuration
#+STARTUP: overview
#+AUTHOR: Mario Forzanini
#+HTML_HEAD: <link rel="stylesheet" href="style/simple.css">
* Look and Feel
** Icons
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package all-the-icons)
#+end_src
** Line numbers
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
      (column-number-mode)
      (global-display-line-numbers-mode t)
      (menu-bar--display-line-numbers-mode-relative)

      (dolist (mode '(term-mode-hook
                      completion-list-mode-hook
                      eshell-mode-hook
                      vterm-mode-hook
                      helpful-mode-hook
                      elfeed-search-mode
                      elfeed-show-mode))
        (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
** Elisp parentheses
Use [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] for nice parentheses coloring
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package rainbow-delimiters
    :defer t
    :commands rainbow-delimiters-mode
    :hook
    (org-mode . rainbow-delimiters-mode)
    (prog-mode . rainbow-delimiters-mode))
#+end_src
** Layout
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (setq display-buffer-alist '(("\\*vterm\\*"  (display-buffer-in-side-window)
                                (side . bottom)
                                (window-height . 0.4))
                               ("\\*Packages\\*" (display-buffer-in-side-window)
                                (side . bottom)
                                (window-height . 0.4))
                               ("\\*WoMan" (display-buffer-in-side-window)
                                (side . bottom)
                                (window-height . 0.4))
                               ("\\*[Hh]elp" (display-buffer-in-side-window)
                                (side . bottom)
                                (window-height . 0.4))))
#+end_src
** Style
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (require 'whitespace)
  (setq whitespace-style '(face empty tabs line-tail trailing)
        whitespace-line-column 80)
  (global-whitespace-mode t)
#+end_src
* Keybindings
** Leader key definitions
*** Helper functions
#+begin_src emacs-lisp  :tangle ~/.emacs.d/Emacs.el
  (defun mf/reload-configuration ()
    "Reloads configuration"
    (interactive)
    (load-file (concat user-emacs-directory "init.el")))

  (defun mf/edit-configuration ()
    "Edit emacs configuration"
    (interactive)
    (find-file "~/.emacs.d/GNUEmacs.org"))

  (defun mf/find-recentf ()
    "Open a recent file"
    (interactive)
    (find-file (completing-read "Recent File: " recentf-list nil t)))

  (defun mf/toggle-vterm (&optional use-generic-p)
    "Toggle vterm window respecting buffer-alist configuration.
    If there is a prefix argument, switch to the vterm buffer."
    (interactive "P")
    (if (get-buffer-window "*vterm*")
        (delete-window (get-buffer-window "*vterm*"))
      (if use-generic-p
          (switch-to-buffer "*vterm*")
        (vterm))))
#+end_src
*** Leader key
Use [[https://github.com/noctuid/general.el][general]] to setup ',' bar as leader key in normal mode, C-SPC in
other modes.
#+begin_src emacs-lisp  :tangle ~/.emacs.d/Emacs.el
  (use-package general
    :init
    (general-override-mode 1)
    :config
    (general-create-definer mf/leader-keys
      :prefix "C-.")
#+end_src
**** General definitions
Commonly used bindings for different purposes; Prefix: C-c
| Keybinding | Action              |
|------------+---------------------|
| SPC-b      | Buffers prefix      |
| SPC-f      | Files prefix        |
| SPC-h      | Help prefix         |
| SPC-i      | Insert prefix       |
| SPC-m      | Major mode prefix   |
| SPC-O      | Org prefix          |
| SPC-q      | Quit prefix         |
| SPC-q-q    | Exit Emacs          |
| SPC-w      | Window prefix       |
| SPC-/      | Music prefix        |
| SPC-SPC    | M-x                 |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/Emacs.el
  (mf/leader-keys
    "a" '(:ignore t :which-key "Applications")
    "b" '(:ignore t :which-key "Buffers")
    "c" '(:ignore t :which-key "Code")
    "f" '(:ignore t :which-key "Files")
    "g" '(:ignore t :which-key "Git")
    "H" '(:ignore t :which-key "Help")
    "i" '(:ignore t :which-key "Insert")
    "j" '(:ignore t :which-key "Jump")
    "q" '(:ignore t :which-key "Quit")
    "t" '(:ignore t :which-key "Toggle")
    "w" '(:ignore t :which-key "Windows")
    "O" '(:ignore t :which-key "Org")

    "," '(execute-extended-command :which-key "M-x")
    "qq" '(save-buffers-kill-terminal :which-key "Exit Emacs")
    "o" '(delete-other-windows :which-key "Only!")
#+end_src
**** Buffer management
Quick bookmarks; Prefix: C-c-b
| Keybinding | Action        |
|------------+---------------|
| SPC-b-d    | Delete buffer |
| SPC-b-r    | Rename buffer |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/Emacs.el
"b"  'switch-to-buffer
"C-b" 'list-buffers
"d"  'kill-current-buffer
#+end_src
**** Code
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/Emacs.el
"cc" 'compile
"ce" 'eval-buffer
"cr" 'recompile
"cE" 'eval-region
"c(" 'check-parens
#+END_SRC
**** File management
Movement in the filesystem; Prefix: C-c-f
| Keybinding | Action                   |
|------------+--------------------------|
| SPC-f-s    | Save buffer              |
| SPC-f-e    | Emacs prefix             |
| SPC-f-e-d  | Edit emacs configuration |
| SPC-f-e-R  | Reload emacs configuration |
#+begin_src emacs-lisp  :tangle ~/.emacs.d/Emacs.el
"fd" 'dired
"ff" 'find-file
"fe" '(:ignore t)
"fed" 'mf/edit-configuration
"feR" 'mf/reload-configuration
"fr" 'mf/find-recentf
"fs" 'save-buffer
#+end_src
**** Windows
    Manage windows; Prefix: SPC-w
| Keybinding | Action           |
|------------+------------------|
| SPC-h      | Focus left       |
| SPC-l      | Focus right      |
| SPC-j      | Focus down       |
| SPC-k      | Focus up         |
| SPC-w-c    | Close            |
| SPC-w-q    | Close            |
| SPC-w-v    | Vertical split   |
| SPC-w-s    | Horizontal split |
| SPC-w-m    | Maximize         |
| SPC-w-=    | Balance windows  |
| SPC-w-w    | Other-window     |
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/Emacs.el
"h" 'windmove-left
"l" 'windmove-right
"j" 'windmove-down
"k" 'windmove-up
"v" 'split-window-right
"s" 'split-window-below
"wc" 'delete-window
"wm" 'maximize-window
"wq" 'delete-window
"w=" 'balance-windows
  ))
#+END_SRC
** Hydra
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package hydra
    :defer t
    :commands hydra-resize/body)
#+end_src
*** Window resizing
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
      (defun mf/window-enlarge ()
        (interactive)
        (shrink-window -6 t))
      (defun mf/window-shrink ()
        (interactive)
        (shrink-window 6 t))
      (defun mf/window-taller ()
        (interactive)
        (shrink-window -6 nil))
      (defun mf/window-shorter ()
        (interactive)
        (shrink-window 6 nil))
      (defun mf/window-big-enlarge ()
        (interactive)
        (shrink-window -12 t))
      (defun mf/window-big-shrink ()
        (interactive)
        (shrink-window 12 t))
      (defun mf/window-big-taller ()
        (interactive)
        (shrink-window -12 nil))
      (defun mf/window-big-shorter ()
        (interactive)
        (shrink-window 12 nil))

      (defhydra hydra-resize (global-map "C-c r")
        "resize"
        ("h" mf/window-shrink)
        ("l" mf/window-enlarge)
        ("j" mf/window-taller)
        ("k" mf/window-shorter)
        ("H" mf/window-big-shrink)
        ("L" mf/window-big-enlarge)
        ("J" mf/window-big-taller)
        ("K" mf/window-big-shorter)
        ("n" windmove-down)
        ("p" windmove-up)
        ("b" windmove-left)
        ("f" windmove-right)
        ("0" delete-window)
        ("2" split-window-below)
        ("3" split-window-right)
        ("q" nil))
#+end_src
*** Buffer cycling
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (defhydra hydra-buf-cycle (global-map "C-c b b")
    "cycle"
    ("d" kill-current-buffer)
    ("j" scroll-up-command)
    ("k" scroll-down-command)
    ("n" bs-cycle-next)
    ("p" bs-cycle-previous)
    ("q" nil))
#+end_src
* Completion framework
** Prescient
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package prescient
    :defer t
    :hook (minibuffer-inactive-mode-hook . prescient-persistent-mode))
#+end_src
** Make use of the Emacs default minibuffer
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package marginalia
    :init
    (marginalia-mode))

  (use-package orderless
    :config
    (defun my-orderless-initialism-dispatcher (pattern _index _total)
      "Leading initialism dispatcher using the comma suffix.
                                   It matches PATTERN _INDEX and _TOTAL according to how Orderless parses it input."
      (when (string-suffix-p "," pattern)
        `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))
    (defun my-orderless-literal-dispatcher (pattern _index _total)
      "Literal style dispatcher using the equal sign as a suffix.
                                   It matches PATTERN _INDEX and _TOTAL according to how Orderless parses it input."
      (when (string-suffix-p "=" pattern )
        `(orderless-literal . ,(substring pattern 0 -1))))
    (defun my-orderless-flex-dispatcher (pattern _index _total)
      "Flex dispatcher using the tilde suffix.
                     It matches PATTERN _INDEX and _TOTAL according to how Orderless
                     parses its input."
      (when (string-suffix-p "~" pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))
    (setq my-orderless-default-styles
          '(orderless-strict-leading-initialism
            orderless-flex
            orderless-prefixes
            orderless-regexp)
          orderless-component-separator "[ &]"      ; Completion at point using & as a separator, SPC automatically exits completion
          orderless-matching-styles my-orderless-default-styles
          orderless-style-dispatchers
          '(my-orderless-literal-dispatcher
            my-orderless-initialism-dispatcher
            my-orderless-flex-dispatcher)
          completion-styles '(orderless))
    (let ((map minibuffer-local-completion-map))
      ;; SPC should never complete, use it for orderless groups'
      (define-key map (kbd "SPC") nil)
      (define-key map (kbd "?") nil)))
#+end_src
From [[https://www.protesilaos.com][protesilaos]] config
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (defun prot-minibuffer-focus-minibuffer ()
    "Focus the active minibuffer."
    (interactive)
    (let ((mini (active-minibuffer-window)))
      (when mini
        (select-window mini))))

  (defun prot-minibuffer--fit-completions-window ()
    "Fit Completions' buffer to its window."
    (fit-window-to-buffer (get-buffer-window "*Completions*")
                          (floor (frame-height) 2) 1))

  (defun prot-common-number-negative ( n )
    "Make N negative."
    (if (and (numberp n) (> n 0))
        (* -1 n)
      (error "%s is not a valid positive number" n)))


  (defun prot-minibuffer--switch-to-completions ()
    "Subroutine for switching to the completions' buffer."
    (unless (get-buffer-window "*Completions*" 0)
      (minibuffer-completion-help))
    (switch-to-completions)
    (prot-minibuffer--fit-completions-window))

  (defun prot-minibuffer-switch-to-completions-top ()
    "Switch to the top of the completions' buffer.
                    Meant to be bound in `minibuffer-local-completion-map'."
    (interactive)
    (prot-minibuffer--switch-to-completions)
    (goto-char (point-min))
    (next-completion 1))

  (defun prot-minibuffer-switch-to-completions-bottom ()
    "Switch to the bottom of the completions' buffer.
                    Meant to be bound in `minibuffer-local-completion-map'."
    (interactive)
    (prot-minibuffer--switch-to-completions)
    (goto-char (point-max))
    (next-completion -1)
    (goto-char (point-at-bol))
    (recenter
     (- -1
        (min (max 0 scroll-margin)
             (truncate (/ (window-body-height) 4.0))))
     t))

  (defun prot-minibuffer-next-completion-or-mini (&optional arg)
    "Move to the next completion or switch to the minibuffer.
                    This performs a regular motion for optional ARG lines, but when
                    point can no longer move in that direction it switches to the
                    minibuffer."
    (interactive "p")
    (cond
     ((and (bobp)   ; see hack in `prot-minibuffer--clean-completions'
           (get-text-property (point) 'invisible))
      (forward-char 1)
      (next-completion (or arg 1)))
     ((or (eobp)
          (eq (point-max)
              (save-excursion (forward-line 1) (point))))
      (prot-minibuffer-focus-minibuffer))
     (t
      (next-completion (or arg 1))))
    (setq this-command 'next-line))

  (defun prot-minibuffer-previous-completion-or-mini (&optional arg)
    "Move to the next completion or switch to the minibuffer.
                    This performs a regular motion for optional ARG lines, but when
                    point can no longer move in that direction it switches to the
                    minibuffer."
    (interactive "p")
    (let ((num (prot-common-number-negative arg)))
      (if (or (bobp)
              (eq (point) (1+ (point-min)))) ; see hack in `prot-minibuffer--clean-completions'
          (prot-minibuffer-focus-minibuffer)
        (next-completion (or num 1)))))
  ;; Copied from icomplete.el
  (defun prot-minibuffer--field-beg ()
    "Determine beginning of completion."
    (if (window-minibuffer-p)
        (minibuffer-prompt-end)
      (nth 0 completion-in-region--data)))
  (defun prot-minibuffer--completion-category ()
    "Return completion category."
    (let* ((beg (prot-minibuffer--field-beg))
           (md (completion--field-metadata beg)))
      (alist-get 'category (cdr md))))
  (defun prot-minibuffer-backward-updir ()
    "Delete char before point or go up a directory.
    Must be bound to `minibuffer-local-filename-completion-map'."
    (interactive)
    (if (and (eq (char-before) ?/)
             (eq (prot-minibuffer--completion-category) 'file))
        (save-excursion
          (goto-char (1- (point)))
          (when (search-backward "/" (point-min) t)
            (delete-region (1+ (point)) (point-max))))
      (call-interactively 'backward-delete-char)))
#+end_src
** Minibuffer completions
Adjust completions buffer size (and all temp buffers)
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (setq temp-buffer-max-height 10)
  (temp-buffer-resize-mode)
#+end_src
Override completion style for buffer and file name completions
(~/.em/el/ expands to ~/.emacs.d/elpa no matter what text there is
befor the ~)
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (file-name-shadow-mode 1)
  (setq completion-styles '(orderless partial-completion))
  (setq completion-category-overrides
        '((buffer (styles . (substring flex orderless)))
          (file (styles . (partial-completion orderless)))))
#+end_src
Set important variables
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (setq completion-cycle-threshold nil)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-show-help nil)
  (setq completion-auto-help t)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq completions-format 'vertical)
  (setq completions-detailed t)
  (setq resize-mini-windows nil)
  (setq minibuffer-eldef-shorten-default t)
  (setq echo-keystrokes 0.25)
  (file-name-shadow-mode 1)
  (minibuffer-electric-default-mode 1)
#+end_src
Keybindings
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (let ((map completion-list-mode-map))
    (define-key map (kbd "C-n") #'prot-minibuffer-next-completion-or-mini)
    (define-key map (kbd "C-p") #'prot-minibuffer-previous-completion-or-mini))
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-n") #'prot-minibuffer-switch-to-completions-top)
    (define-key map (kbd "C-p") #'prot-minibuffer-switch-to-completions-bottom)
    (define-key map (kbd "RET") #'minibuffer-force-complete-and-exit))
  (let ((map minibuffer-local-filename-completion-map))
    (define-key map (kbd "<M-backspace>") #'prot-minibuffer-backward-updir))
#+end_src
** Corfu
Use corfu for better completions at point
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package corfu
    :config (corfu-global-mode))
#+end_src
* Helpful
Use [[https://github.com/Wilfred/helpful][helpful]] to get better help, highlighting and references to the
source files
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package page-break-lines
    :defer t
    :commands page-break-lines-mode)

  (use-package helpful
    :defer t
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :hook
    (helpful-mode . page-break-lines-mode)
    (helpful-mode . visual-line-mode)
    :bind
    ([remap describe-variable] . helpful-variable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key)
    (:map helpful-mode-map
          ("q" . mf/quit-and-kill)					; Quitting help buffer kills them too
          ("n" . next-line)
          ("p" . previous-line))
    :config
    (defun mf/quit-and-kill ()
      (interactive)
      (quit-window t)))
#+end_src
* Programming
** Autocompletion
Get [[http://company-mode.github.io/][autocompletion]]. Edit: try to use Emacs' built in completion-at-point
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (setq tab-always-indent 'complete)
  (autoload 'ffap-file-at-point "ffap")
  (defun complete-path-at-point+ ()
    "Return completion data for UNIX path at point."
    (let ((fn (ffap-file-at-point))
          (fap (thing-at-point 'filename)))
      (when (and (or fn (equal "/" fap))
                 (save-excursion
                   (search-backward fap (line-beginning-position) t)))
        (list (match-beginning 0)
              (match-end 0)
              #'completion-file-name-table :exclusive 'no))))

  (add-hook 'completion-at-point-functions
            #'complete-path-at-point+
            'append)
#+end_src
** Projectile
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package projectile
    :defer t
    :commands projectile-mode
    :hook
    (c-mode . projectile-mode)
    (c++-mode . projectile-mode)
    (haskell-mode . projectile-mode)
    (emacs-lisp-mode . projectile-mode))
#+end_src
** Go
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package go-mode
    :defer t
    :commands go-mode)
#+end_src
** Haskell
#+begin_src emacs-lisp

  (use-package hindent
    :defer t
    :commands hindent-mode
    :hook (haskell-mode-hook . hindent-mode)
    :config (setq hindent-reformat-buffer-on-save t))

  (use-package dante
    :after haskell-mode
    :commands dante-mode
    :init
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
    (add-hook 'haskell-mode-hook 'flycheck-mode)
    (add-hook 'haskell-mode-hook 'dante-mode))
#+end_src
** Smart parentheses
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package smartparens
    :defer t
    :commands smartparens-mode
    :hook
    ((prog-mode . smartparens-mode)
    (emacs-lisp-mode . smartparens-mode)
    (org-mode . smartparens-mode)
    (scheme-mode . smartparens-mode))
    :config
    (require 'smartparens-config))
#+END_SRC
** Git
Use magit to handle git repositories
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/Emacs.el
(use-package magit
  :defer t
:commands magit
:general (mf/leader-keys
		  "gb" 'magit-branch-checkout
		  "gc" '(:ignore t)
		  "gcb" 'magit-branch-and-checkout
		  "gcc" 'magit-commit-create
		  "gcr" 'magit-init
		  "gcR" 'magit-clone
		  "gf" '(:ignore t)
		  "gfc" 'magit-show-commit
		  "gfg" 'magit-find-git-config-file
		  "gg" 'magit-status
		  "gt" 'git-timemachine-toggle
		  "gB" 'magit-blame-addition
		  "gC" 'magit-clone
		  "gD" 'magit-file-delete
		  "gF" 'magit-fetch
		  "gG" 'magit-status-here
		  "gL" 'magit-log
		  "gS" 'magit-stage-file
		  "gU" 'magit-unstage-file))
#+END_SRC
* Shell
*** eshell
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (defun mf/configure-eshell ()
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer))

  (use-package eshell-git-prompt
    :defer t
    :after eshell)
  (use-package eshell
    :defer t
    :commands eshell
    :hook (eshell-first-time-mode . mf/configure-eshell)
    :config
    (setq eshell-history-size 5000
          eshell-buffer-maximum-lines 5000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t)
    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "sh"))
      (eshell-git-prompt-use-theme 'powerline)))
#+end_src
*** vterm
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
      (use-package vterm
        :defer t
        :commands vterm
        :config
        (setq vterm-shell "/bin/sh")
        :general (mf/leader-keys
                   "RET" '(mf/toggle-vterm :which-key "vterm")))
#+end_src
* Org mode
** Setup
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
    (defun mf/org-mode-setup ()
          (org-indent-mode)
          (visual-line-mode 1))
#+end_src
** Org
#+begin_src emacs-lisp :tangle ~/.emacs.d/Emacs.el
  (use-package org
    :defer t
    :hook (org-mode . mf/org-mode-setup)
    :general (mf/leader-keys
               "Ot" '(:ignore t :which-key "Tangle")
               "Ott" '(org-babe-tangle :which-key "Tangle")
               "Otl" '(org-babel-load-file :which-key "Load file"))
    :config
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))
#+end_src
** In line latex previews
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/Emacs.el
        (use-package org-fragtog
          :defer t
          :after org
          :hook
         (org-mode . org-fragtog-mode)
         :bind (:map org-mode-map
                     ("C-c tf" . org-fragtog-mode)))
#+END_SRC
